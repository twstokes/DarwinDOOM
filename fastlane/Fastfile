require "fileutils"

default_platform(:mac)

platform :mac do
  desc "Build, sign, and create a GitHub release for macOS (local build)."
  lane :release_macos do |options|
    version = options[:version]
    repo = options[:repo] || "twstokes/DarwinDOOM"
    identity = options[:identity] || "DarwinDOOM"
    bundle_id = options[:bundle_id] || "com.tannr.DarwinDOOM"
    provisioning_profile = options[:provisioning_profile]
    allow_dirty = options.key?(:allow_dirty) ? options[:allow_dirty] : false
    project_root = Dir.pwd.end_with?("fastlane") ? File.expand_path("..", Dir.pwd) : Dir.pwd
    build_dir = options[:build_dir] || File.join(project_root, "build")
    notes = options[:notes]
    push_tag = options.key?(:push_tag) ? options[:push_tag] : true
    dry_run = options.key?(:dry_run) ? options[:dry_run] : false
    notarize = options.key?(:notarize) ? options[:notarize] : false
    notary_profile = options[:notary_profile] || "DarwinDOOM-notary"

    UI.user_error!("Pass version: `fastlane mac release_macos version:1.2.3`") if version.to_s.strip.empty?
    UI.user_error!("Release canceled.") unless UI.confirm("Proceed with version #{version}?")

    ensure_git_status_clean unless allow_dirty

    versions_path = File.join(project_root, "Config", "Versions.xcconfig")
    UI.user_error!("Missing Versions.xcconfig at #{versions_path}") unless File.exist?(versions_path)
    xcconfig = File.read(versions_path)
    xcconfig = xcconfig.gsub(/^\s*MARKETING_VERSION\s*=.*$/, "MARKETING_VERSION = #{version}")
    File.write(versions_path, xcconfig)
    status = sh("git", "status", "--porcelain", versions_path).to_s.strip
    if !status.empty?
      if UI.confirm("Commit version bump to #{version}?")
        sh("git", "add", versions_path)
        sh("git", "commit", "-m", "Bump version to #{version}")
        sh("git", "push", "origin", "HEAD")
      else
        UI.user_error!("Release canceled (version bump not committed).")
      end
    end

    output_name = "DarwinDOOM"
    output_path = nil
    zip_name = "DarwinDOOM-#{version}-macOS.zip"
    zip_path = File.join(build_dir, zip_name)

    FileUtils.mkdir_p(build_dir)

    export_options = {
      teamID: "AE76EV48ND"
    }
    if provisioning_profile && !provisioning_profile.to_s.strip.empty?
      export_options[:signingStyle] = "manual"
      export_options[:signingCertificate] = identity
      export_options[:provisioningProfiles] = { bundle_id => provisioning_profile }
    else
      export_options[:signingStyle] = "automatic"
    end

    build_app(
      scheme: "DarwinDOOM",
      configuration: "Release",
      destination: "generic/platform=macOS",
      output_directory: build_dir,
      output_name: output_name,
      export_method: "developer-id",
      codesigning_identity: identity,
      export_options: export_options
    )

    expanded_build_dir = File.expand_path(build_dir)
    output_path = File.join(expanded_build_dir, "#{output_name}.app")
    output_path = Dir.glob(File.join(expanded_build_dir, "*.app")).first unless File.exist?(output_path)
    UI.user_error!("Built app not found in #{expanded_build_dir}") if output_path.nil?

    sh("rm", "-f", zip_path)
    sh("ditto", "-c", "-k", "--sequesterRsrc", "--keepParent", output_path, zip_path)

    if dry_run
      UI.message("Dry run enabled; skipping notarization and release prompts.")
      next
    end

    do_notarize = notarize || UI.confirm("Notarize the build now?")
    if do_notarize
      UI.user_error!("Pass notary_profile: `notary_profile:MyProfile`") if notary_profile.to_s.strip.empty?
      sh("xcrun", "notarytool", "submit", zip_path, "--keychain-profile", notary_profile, "--wait")
      sh("xcrun", "stapler", "staple", output_path)
    end

    if UI.confirm("Create a GitHub tag and draft release?")
      tag = "v#{version}"
      begin
        sh("git", "rev-parse", "-q", "--verify", tag)
      rescue
        sh("git", "tag", tag)
        sh("git", "push", "origin", tag) if push_tag
      end

      args = ["gh", "release", "create", tag, zip_path, "--repo", repo, "--title", tag, "--draft"]
      if notes && !notes.to_s.strip.empty?
        args += ["--notes", notes]
      else
        args += ["--notes", "Release #{tag}"]
      end
      sh(*args)
    end
  end
end
